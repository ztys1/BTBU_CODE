/*
从键盘上分别输入2个数组，每个数组都有10个数
（可能有相同数），求其并集。
并集按照第一个集合数的顺序为先,
第二个集合不同数补其后顺序构建并输出。

思路：输入a的同时，初始化并集。
第一个大循环，对初始化的u进行元素去重
第二个大循环，将b中元素补充到u中
对a去重和的过程，数组元素下标
*/
#include <stdio.h>
int main()
{
    int i,j,k;
    int a[10];//={11,22,34,51,34,11,76,78,89,90};
    int b[10];//={13,12,35,66,78,90,11,11,55,78};
    int u[20];
    int c=0;//存放a的重复元素个数
    int count=0;//存放b需要放入并集的元素
    int flag=0;
    for(i=0; i<10; i++)//输入a
    {
        scanf("%d",&a[i]);
        u[i] = a[i];//同时初始化u
    }
    for(i=0; i<10; i++) //输入b
        scanf("%d",&b[i]);

    for(i=0; i<10-c; i++)//对初始的u做元素去重
    {
        for(j=0; j<i; j++)//判断u的元素是否有重
            if(u[i]==u[j])//如果有重
            {
                for(k=i; k<10-c; k++)//将j后的数往前挪
                    u[k] = u[k+1];
                c++;//用c记录a中重复元素个数
                i--;//需要重新判断从j后挪过来的新数
            }
    }

    //count = -c;
    for(i=0; i<10; i++)//逐一查看b中的元素
    {
        for(j=0; j<10; j++)//b的元素在a中是否存在
        {
            if(b[i]==a[j])
            {
                flag = 1;//存在
                break;
            }
        }
        if(flag == 0)//不存在
        {
            count++;//b中需要放入并集的元素个数
            u[9-c+count] = b[i];//b的元素补在u后边，9-count是a去重后最后一个元素的索引
        }            
        flag = 0;
    }

    for(i=0; i<(10-c)+count; i++)//输出
    {
        printf("%d,",u[i]);
    }
    printf("\n");
    return 0;
}